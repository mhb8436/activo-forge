package jmeter

import (
	"encoding/xml"
	"fmt"
	"net/url"
	"os"
	"strings"

	"activo-forge/har"
)

// GenerateOptions JMX 생성 옵션
type GenerateOptions struct {
	Threads        int
	Loops          int
	FilterDomain   string
	ExcludeStatic  bool
	IncludeHeaders bool
}

// GenerateResult 생성 결과
type GenerateResult struct {
	RequestCount int
	SkippedCount int
}

// 정적 리소스 확장자
var staticExtensions = []string{
	".js", ".css", ".png", ".jpg", ".jpeg", ".gif", ".ico",
	".woff", ".woff2", ".ttf", ".eot", ".svg", ".webp",
	".map", ".mp4", ".webm", ".mp3", ".wav",
}

// Generate HAR를 JMX로 변환합니다
func Generate(harData *har.HAR, outputPath string, opts GenerateOptions) (*GenerateResult, error) {
	result := &GenerateResult{}

	// 테스트 플랜 생성
	testPlan := createTestPlan()

	// 스레드 그룹 생성
	threadGroup := createThreadGroup(opts.Threads, opts.Loops)

	// HTTP 샘플러 생성
	var samplers []interface{}
	requestNum := 0

	for _, entry := range harData.Log.Entries {
		// 도메인 필터
		if opts.FilterDomain != "" && !strings.Contains(entry.Request.URL, opts.FilterDomain) {
			result.SkippedCount++
			continue
		}

		// 정적 리소스 필터
		if opts.ExcludeStatic && isStaticResource(entry.Request.URL) {
			result.SkippedCount++
			continue
		}

		requestNum++
		sampler, err := createHTTPSampler(requestNum, entry, opts.IncludeHeaders)
		if err != nil {
			continue
		}
		samplers = append(samplers, sampler)
		samplers = append(samplers, HashTree{}) // 빈 해시트리
		result.RequestCount++
	}

	// XML 구조 조립
	doc := JMeterTestPlan{
		Version:    "1.2",
		Properties: "5.0",
		Jmeter:     "5.6.3",
		HashTree: HashTree{
			Items: []interface{}{
				testPlan,
				HashTree{
					Items: append([]interface{}{
						threadGroup,
						HashTree{
							Items: samplers,
						},
					}),
				},
			},
		},
	}

	// XML 마샬링
	output, err := xml.MarshalIndent(doc, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("XML 생성 실패: %w", err)
	}

	// XML 헤더 추가
	xmlContent := []byte(xml.Header + string(output))

	// 파일 저장
	if err := os.WriteFile(outputPath, xmlContent, 0644); err != nil {
		return nil, fmt.Errorf("파일 저장 실패: %w", err)
	}

	return result, nil
}

func createTestPlan() TestPlan {
	return TestPlan{
		GuiClass:  "TestPlanGui",
		TestClass: "TestPlan",
		TestName:  "Activo-Forge Test Plan",
		Enabled:   "true",
		BoolProps: []BoolProp{
			{Name: "TestPlan.functional_mode", Value: false},
			{Name: "TestPlan.tearDown_on_shutdown", Value: true},
			{Name: "TestPlan.serialize_threadgroups", Value: false},
		},
		StringProps: []StringProp{
			{Name: "TestPlan.comments", Value: "Generated by Activo-Forge"},
			{Name: "TestPlan.user_define_classpath", Value: ""},
		},
		ElementProp: ElementProp{
			Name:        "TestPlan.user_defined_variables",
			GuiClass:    "ArgumentsPanel",
			TestClass:   "Arguments",
			ElementType: "Arguments",
			CollectionProp: CollectionProp{
				Name: "Arguments.arguments",
			},
		},
	}
}

func createThreadGroup(threads, loops int) ThreadGroup {
	return ThreadGroup{
		GuiClass:  "ThreadGroupGui",
		TestClass: "ThreadGroup",
		TestName:  "Thread Group",
		Enabled:   "true",
		StringProps: []StringProp{
			{Name: "ThreadGroup.on_sample_error", Value: "continue"},
			{Name: "ThreadGroup.num_threads", Value: fmt.Sprintf("%d", threads)},
			{Name: "ThreadGroup.ramp_time", Value: "1"},
			{Name: "ThreadGroup.duration", Value: ""},
			{Name: "ThreadGroup.delay", Value: ""},
		},
		BoolProps: []BoolProp{
			{Name: "ThreadGroup.same_user_on_next_iteration", Value: true},
			{Name: "ThreadGroup.scheduler", Value: false},
		},
		ElementProp: LoopControllerProp{
			Name:        "ThreadGroup.main_controller",
			GuiClass:    "LoopControlPanel",
			TestClass:   "LoopController",
			ElementType: "LoopController",
			BoolProps: []BoolProp{
				{Name: "LoopController.continue_forever", Value: false},
			},
			StringProps: []StringProp{
				{Name: "LoopController.loops", Value: fmt.Sprintf("%d", loops)},
			},
		},
	}
}

func createHTTPSampler(num int, entry har.Entry, includeHeaders bool) (HTTPSamplerProxy, error) {
	parsed, err := url.Parse(entry.Request.URL)
	if err != nil {
		return HTTPSamplerProxy{}, err
	}

	// 포트 결정
	port := parsed.Port()
	if port == "" {
		if parsed.Scheme == "https" {
			port = "443"
		} else {
			port = "80"
		}
	}

	// 경로에서 쿼리 제거
	path := parsed.Path
	if path == "" {
		path = "/"
	}

	sampler := HTTPSamplerProxy{
		GuiClass:  "HttpTestSampleGui",
		TestClass: "HTTPSamplerProxy",
		TestName:  fmt.Sprintf("%03d - %s %s", num, entry.Request.Method, truncatePath(path, 50)),
		Enabled:   "true",
		BoolProps: []BoolProp{
			{Name: "HTTPSampler.follow_redirects", Value: true},
			{Name: "HTTPSampler.auto_redirects", Value: false},
			{Name: "HTTPSampler.use_keepalive", Value: true},
			{Name: "HTTPSampler.DO_MULTIPART_POST", Value: false},
		},
		StringProps: []StringProp{
			{Name: "HTTPSampler.domain", Value: parsed.Hostname()},
			{Name: "HTTPSampler.port", Value: port},
			{Name: "HTTPSampler.protocol", Value: parsed.Scheme},
			{Name: "HTTPSampler.path", Value: path},
			{Name: "HTTPSampler.method", Value: entry.Request.Method},
			{Name: "HTTPSampler.contentEncoding", Value: "UTF-8"},
			{Name: "HTTPSampler.connect_timeout", Value: ""},
			{Name: "HTTPSampler.response_timeout", Value: ""},
		},
	}

	// 쿼리 파라미터 처리
	if len(entry.Request.QueryString) > 0 {
		var args []HTTPArgument

		for _, q := range entry.Request.QueryString {
			args = append(args, HTTPArgument{
				Name:        "HTTPArgument",
				ElementType: "HTTPArgument",
				StringProps: []StringProp{
					{Name: "Argument.name", Value: q.Name},
					{Name: "Argument.value", Value: q.Value},
					{Name: "Argument.metadata", Value: "="},
				},
				BoolProps: []BoolProp{
					{Name: "HTTPArgument.always_encode", Value: true},
					{Name: "HTTPArgument.use_equals", Value: true},
				},
			})
		}

		if len(args) > 0 {
			sampler.ElementProp = &ElementPropArgs{
				Name:        "HTTPsampler.Arguments",
				GuiClass:    "HTTPArgumentsPanel",
				TestClass:   "Arguments",
				ElementType: "Arguments",
				CollectionProp: CollectionPropArgs{
					Name:  "Arguments.arguments",
					Items: args,
				},
			}
		}
	}

	// POST 데이터 처리
	if entry.Request.PostData != nil && entry.Request.PostData.Text != "" {
		sampler.BoolProps = append(sampler.BoolProps,
			BoolProp{Name: "HTTPSampler.postBodyRaw", Value: true},
		)
		sampler.ElementProp = &ElementPropArgs{
			Name:        "HTTPsampler.Arguments",
			GuiClass:    "HTTPArgumentsPanel",
			TestClass:   "Arguments",
			ElementType: "Arguments",
			CollectionProp: CollectionPropArgs{
				Name: "Arguments.arguments",
				Items: []HTTPArgument{
					{
						Name:        "HTTPArgument",
						ElementType: "HTTPArgument",
						StringProps: []StringProp{
							{Name: "Argument.value", Value: entry.Request.PostData.Text},
							{Name: "Argument.metadata", Value: "="},
						},
						BoolProps: []BoolProp{
							{Name: "HTTPArgument.always_encode", Value: false},
						},
					},
				},
			},
		}
	}

	return sampler, nil
}

func isStaticResource(urlStr string) bool {
	lower := strings.ToLower(urlStr)
	for _, ext := range staticExtensions {
		if strings.Contains(lower, ext+"?") || strings.HasSuffix(lower, ext) {
			return true
		}
	}
	return false
}

func truncatePath(path string, maxLen int) string {
	if len(path) <= maxLen {
		return path
	}
	return path[:maxLen-3] + "..."
}
